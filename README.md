舒钦瑜_2017152044_期末大作业-验证码识别
目录
# 一、介绍
给定4000个验证码数据，每个验证码数据由10个数字或者字母组成，字母区分大小写，编写一个判别器，将这4000个验证码数据进行输入训练后，能完成基本的验证码识别工作。如下图所示能够正确的判别验证码内的数据：

![](https://i.niupic.com/images/2020/06/24/8jlH.png)

该4000组验证码的数据大致分为四大类：
1. 正常的没有进行模糊处理和添加噪声的验证码

![](https://i.niupic.com/images/2020/06/24/8jlI.png)

2. 经过模糊化处理之后的验证码

![](https://i.niupic.com/images/2020/06/24/8jlN.png)

3. 添加了很多噪声的验证码

![](https://i.niupic.com/images/2020/06/24/8jlM.png)

4. 经过模糊处理和添加了大量噪声的验证码

![](https://i.niupic.com/images/2020/06/24/8jlO.png)

我对于该验证码识别的大致思路是先对数据进行预处理降噪来去除椒盐噪声，图像增强来将模糊的部分进行清晰化，然后将10个数字或者是字母进行分离，最后通过一个BP神经网络进行训练，后续进行识别的时候通过该验证码进行分割，进入到该BP神经网络进行分类输出，最后组合所有的分割之后识别的数据为最后的识别结果。

# 二、数据分析以及预处理
## 1、灰度化
为了简化后续的运算，我们先将图像进行灰度化，将图像灰度化在OpenCV内可以不用显示的转化，可以在读入图像数据的时候就指定图像的格式为灰度图像，反映到代码层面为：`Mat mat = imread("path_to_image", CV_8UC1);`，最后一个参数即为将读入的图像作为灰度图像。
## 2、图像锐化
我们可以使用空间滤波进行图像锐化操作，使得被模糊化的图像更加清晰一些。这里我们使用的滤波器为拉普拉斯滤波器：

![](https://i.niupic.com/images/2020/06/24/8jmG.png)

$$
\left\{
 \begin{matrix}
   0 & -1 & 0 \\
   -1 & 5 & -1 \\
   0 & -1 & 0
  \end{matrix}
  \right\} \tag{拉普拉斯算子}
$$
对于像素点，我们可以基于这个拉普拉斯算子的简单算法主要是遍历图像中的像素点，根据其邻域像素点的值来确定其锐化后的值，计算公式为：`sharpened_pixel = 5 * current – left – right – up – down`，反应到C++的OpenCV内的代码如下：

```C++
//拉普拉斯算子
Mat Kernel(3, 3, CV_8SC1);
short scalar[3][3] = {
        {0,  -1, 0},
        {-1, 5,  -1},
        {0,  -1, 0}
};
//赋值
for (int i = 0; i < 3; i++)
    for (int j = 0; j < 3; j++)
        Kernel.at<short>(i, j) = scalar[i][j];
```
然后我们使用OpenCV内的`filter2D(mat, mat, -1, Kenel)`函数即可完成图像与拉普拉斯算子的卷积操作，即进行图像锐化的处理。锐化前后对比图如下：

![](https://i.niupic.com/images/2020/06/24/8jlU.png)

可以看到我们经过拉普拉斯算子的卷积操作之后图像相比原图像是清晰很多的。
## 3、图像降噪
同样的，我们也使用空间滤波进行图像的降噪处理，而中值滤波和均值滤波算法对于降噪来说是效果比较好的一种算法，但是我们这次验证码的噪声是椒盐噪声，而中值滤波作为一种非线性滤波能够很好的消除椒盐噪声，而均值滤波作为一种线性滤波器对椒盐噪声的消除效果不是很好，所以我们在这里使用的降噪算法为中值滤波。

中值滤波，顾名思义就是这些像素点的中间值，当我们的滤波器的大小给到3时，如下为中间像素点的周围像素点：

![](https://i.niupic.com/images/2020/06/24/8jm5.png)

我们需要将这9个像素点从高到低（或者从低到高）进行排序，然后取他们的中位数，即中值作为我们该像素的值。

中值滤波在OpenCV内的函数为`medianBlur(mat, mat, 3);`，最后的参数3代表的是滤波器的大小，我们这里选择的大小为3，即3*3的滤波器。我们使用一张带有椒盐噪声的验证码图像使用中值滤波进行降噪，运行结果如下：

![](https://i.niupic.com/images/2020/06/24/8jm9.png)

可以看到我们的经过之前的锐化和这次的降噪（主要是降噪）操作之后我们图像的噪声相比原图像之后已经减少很多了。
## 4、8邻域降噪
8邻域降噪作为在验证码内降噪比较常用的一种算法，其前提是将图片灰度化，在灰度图像内越接近白色的点像素越接近255，越接近黑色的点像素越接近0，而验证码字符肯定是非白色的。对于其中噪点大部分都是孤立的小点的，而且字符都是串联在一起的。

8邻域降噪的原理就是依次遍历图中所有非白色的点，计算其周围8个点中属于非白色点的个数，如果数量小于一个固定值，那么这个点就是噪点。对于不同类型的验证码这个阈值是不同的，所以可以在程序中配置，不断尝试找到最佳的阈值。

经过测试发现8邻域降噪对于小的噪点的去除是比较有效的，而且计算量不大，下图是阈值设置为4去噪后的结果：

![](https://i.niupic.com/images/2020/06/24/8jmp.png)

其中8邻域降噪法的代码实现如下：
```C++
//计算邻域非白色的个数
size_t calculateNoiseCount(Mat &img, size_t indexI, size_t indexJ) {
    size_t count = 0;
    size_t rows = img.rows;
    size_t cols = img.cols;
    for (size_t i = indexI - 1; i < indexI + 1; i++) {
        if (i < 0 || i >= rows)
            continue;
        for (size_t j = indexJ - 1; j < indexJ + 1; j++) {
            if (j < 0 || j >= cols)
                continue;
            if (img.at<uchar>(i, j) < 255)
                count++;
        }
    }
    return count;
}

//8邻域降噪，如果该点为黑，但是周围黑点小于4，那么则认为这个点是噪声
void noiseReduction(Mat &img, int k = 4) {
    std::vector<std::pair<size_t, size_t>> indexes;
    for (size_t i = 0; i < img.rows; i++) {
        for (size_t j = 0; j < img.cols; j++) {
            if (img.at<uchar>(i, j) < 255) {
                if (calculateNoiseCount(img, i, j) < 4)
                    indexes.emplace_back(i, j);
            }
        }
    }
    for (std::pair<size_t, size_t> pair:indexes) {
        img.at<uchar>(pair.first, pair.second) = 255;
    }
}
```
在后续操作中我会将8邻域降噪法和之前的中值滤波一起使用，即先进行中值滤波，再进行8邻域降噪（后进行8邻域降噪的原因是因为8邻域降噪法会将验证码字符的轨迹变细，会影响中值滤波降噪的操作）。将二者进行结合之后的图像降噪之后的效果如下图所示：

![](https://i.niupic.com/images/2020/06/24/8jmz.png)

可以看到效果比之前的单纯的中值滤波降噪和8邻域降噪的效果要好一些。
### 5、二值化
二值化，这一步主要是将上图中周围有一些灰度的去除，在代码内实现就比较简单了，OpenCV内有专门的二值化函数，我这里的代码如下：

```C++
threshold(mat, mat, 0, 255, THRESH_OTSU);
mat = 255 - mat;
```
最后经过上述的步骤处理结果如下图所示：

![](https://i.niupic.com/images/2020/06/24/8jmK.png)

我们选择一张既经过模糊化处理，又经过添加噪声之后的图像进行上述的处理，结果如下：

![](https://i.niupic.com/images/2020/06/24/8jmQ.png)

可以看到虽然结果还是不尽如人意，但是相比较原始的图像数据来说已经能看清大致了。

# 三、实现过程
（请在此处描述算法的基本思路，特征的选择和提取、分类器模型等，附上你的关键代码，解释代码的作用，遇到的错误以及解决方法等）

# 四、项目结果
（请在此处描述你的实验结果，采用图表的形式与现有其他方法的对比，并加以说明。 同时分析算法的优缺点，给出优化方案的思考等。）

# 五、项目总结
（此处写写你的所想、所得）

参考文献

